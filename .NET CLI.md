- commands structure
- `<driver/program> <command> [arguments] [options]`
- here driver is `dotnet`
- in context of dotnet there are two usages:
- `dotnet [runtime options] [path to app] [args]` ------> to run a project
- `dotnet [sdk options] [command] [command options] [args]` ---> to run a cmd

- you can look through all these options and commands by typing `dotnet --help` in cmd

- `dotnet new gitignore` --> crates a gitignore file that already has a lot in it
- `dotnet new --list` --> lists all what you can create
- `dotnet new sln` --> creates a solutions file (.sln) (with nothing in it) with the same name as of the folder it's in
- `dotnet new console` --> makes a console app, DEFAULT LANGUAGE FOR ALL THIS is C#.
- -o <location/> ----> location to put the output of the command
- `dotnet sln add <ProjLocation>` ---> add the project in the solution file of the directory
- `dotnet new classlib -o <a name for that library>` --> creates a standard class
- `dotnet add package <NuGet package name>` --> need to be in a project folder to run this, it adds the latest version of the given NuGet package.
  It adds it into the references of the project you're in. (in the .csproj file)
- In our console app, we can add reference to the class lib file, `dotnet add reference <addr of class lib>`
- `dotnet restore` --> downloads all the mentioned (in .csproj file) Nuget packages' combiled binaries in the global cache.
- `dotnet build` --> compiles the project and creates assemblies (like .dll or .exe) based on your code, inside the bin/ folder. This first internally calls the restore command first, to install all the packages. If there is a previous build available, then it only makes changes to it, and doesn't write the whole thing all over again.
- `dotnet clean` --> deletes all files generated by the previous dotnet build (or publish) from the projectâ€™s output folders like bin/ and obj/.
  It doesn't delete the source code, just the build artifacts and it also doesn't affect the nuget packages.
- `dotnet rebuild` --> shortcut for: `dotnet clean` and then `dotnet build`
  this one redoes everything, since it cleans all the previous builds first.
- `dotnet run` ---> runs our application on the console. (the compiled dlls or exes), if some changes are detected, then it builds first before executing.


- `dotnet publish` - builds your app and produces a self-contained, ready-to-deploy output inside publish/ â€” for production use.
  Basically it compiles and bundles everything and make everything ready for the target OS
  
    Deployment targets:
    1. Framework dependent build (default):
      `dotnet publish -c Release` --> requires .NET runtime on target machine. The output of this command is smaller.
    2. Self-contained build (includes runtime):
      `dotnet publish -c Release -r win-x64 --self-contained true`
        Includes everything: .NET runtime + your code.
        Target machine needs nothing installed.
        ðŸ”º Bigger size, but plug-and-play.
    3. Single-File Deployment
       `dotnet publish -c Release -r win-x64 --self-contained true /p:PublishSingleFile=true`
       Packing the entire app and the .NET runtime into a single executable file.
